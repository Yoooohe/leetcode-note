子集问题（无重复不可复选）：- 78
 - 通过传入start为i+1控制树枝的遍历，避免产生重复子集
 - 前序位置的每个节点值都是一个子集，都进行收集

组合问题（无重复不可复选）：- 77
 - 通过传入start为i+1控制树枝的遍历，避免产生重复子集
 - 稍改 base case，控制算法仅仅收集第 k 层节点的值即可

排列问题（无重复不可复选）：- 46
 - 排列问题本身就是让你穷举元素的位置，nums[i] 之后也可以出现 nums[i] 左边的元素，所以之前使用start参数的方式玩不转了，需要额外使用 used 数组来标记哪些元素还可以被选择。
 - 仅收集k层节点

----------------------------------

子集/组合（可重复不可复选）：- 90
 - 需要进行排序，让相同元素靠在一起，如果发现i > start && nums[i] == nums[i-1]，则跳过

排列问题（可重复不可复选）：- 47
 - 排序
 - 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置：i > 0 && nums[i] == nums[i - 1] && used[i - 1]

----------------------------------
子集/组合（无重复可复选）： - 39
- 如果想让每个元素被重复使用，只要把传入的start从 i + 1 改成 i 即可

排列问题（无重复可复选）
- 放飞自我，不需要start，不需要used数组









